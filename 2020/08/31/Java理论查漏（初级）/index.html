<!DOCTYPE html>
<html lang="zh-CN">





<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="27z_W5AnQzBSH6OUQE1R9SFm194-UyXDI_iVWTSZ4qw" />
    <link rel="apple-touch-icon" sizes="76x76" href="/silmont2000.github.io/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/silmont2000.github.io/img/favicon.jpg">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <meta name="theme-color" content="#2f4154">
    <meta name="description" content=" 找个地方记录自己的学习和成长&lt;br&gt; 写不出东西的时候就去草坪晒个太阳&lt;br&gt; 堕落街吃个鸡丝拌面缙云烧饼摩天脆脆&lt;br&gt; 之后虽然还是写不出来&lt;br&gt; 但日子又好过很多了&lt;br&gt;">
    <meta name="author" content="Silmont">
    <meta name="keywords" content="">
    <title>Java理论查漏 - 今天也有晒太阳欸</title>

    <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/silmont2000.github.io/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/silmont2000.github.io/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/silmont2000.github.io/">&nbsp;<strong>小谢的零食屋qwq</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/silmont2000.github.io/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/silmont2000.github.io/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/silmont2000.github.io/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/silmont2000.github.io/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/silmont2000.github.io/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/silmont2000.github.io/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期一, 八月 31日 2020, 3:48 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    9.1k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      36 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h1 id="Java理论查漏（初级）"><a href="#Java理论查漏（初级）" class="headerlink" title="Java理论查漏（初级）"></a>Java理论查漏（初级）</h1><h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><ol>
<li><p>JAVA图形界面组件层次关系（SWING）：</p>
<p>主要是window、canvas、button、checkbox、labe、levent、dialog</p>
<p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/20190223221456236.jpg?token=ANRR26L4OXD3DKUIT6QJSMC7JSXI2" srcset="/silmont2000.github.io/img/loading.gif" alt="img"></p>
<p>图源<a href="https://blog.csdn.net/zengxiantao1994/article/details/87898107" target="_blank" rel="noopener">https://blog.csdn.net/zengxiantao1994/article/details/87898107</a></p>
</li>
<li><p>JAVA程序运行不受系统限制。原本.class字节码文件需要java虚拟机解释称机器码才能执行，速度较慢，随着JVM（java虚拟机）的发展，执行速度直逼C++。结构：.java-&gt;编译器-&gt;字节码文件.class-&gt;解释器（JVM）</p>
</li>
<li><p><strong>JDK Java Development Kit</strong> 是Sun公司推出的Java开发工具包，包括<strong>Java类库、 Java编译器、 Java解释器、 Java运行环境和Java命令行工具</strong>。JDK主要有3种版本<br>J2SE：standard edition,  Java标准版或Java标准平台。可以开发Java桌面应用程序和低端服务器应用程序，也可开发Java Applet程序<br>J2EE：enterpsise edtion, Java企业版或Java企业平台,它包含J2SE平台，并增加了附加类库，支持目录管理，交易管理等功能。<br>J2ME：micro edtion,Java微型版或Java小型平台,用于嵌入式的消费产品中，如移动电话，掌上电脑等</p>
<p>普通用户只需要安装 JRE来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序</p>
<p>javac.exe是编译器</p>
</li>
<li><p><strong>JRE</strong>   Java runtime environment 是运行基于Java语言编写的程序所不可缺少的运行环境，用于解释执行Java的字节码文件。bin里的就是JVM，lib中则是JVM工作所需要的类库，<strong>而JVM和 lib和起来就称为JRE</strong></p>
</li>
<li><p><strong>JVM</strong>：Java Virtual Machine 是Java的虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。</p>
<p>所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。</p>
</li>
<li><p><strong>编译执行和解释执行：</strong>编译过程只进行一次，所以，编译过程的速度并不是关键，目标代码的运行速度是关键。因此，编译器一般都集成尽可能多的优化技术，使生成的目标代码具备更好的执行效率。解释则在每次程序运行时都需要解释器和源代码，不能集成太多优化技术，因为代码优化技术会消耗运行时间，使整个程序的执行速度受到影响。区别有点像笔译和同声传译的区别。</p>
</li>
<li><p><strong>java没有头文件、指针、结构体、运算符重载、多重继承、无符号常量。</strong></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200827142041106.png?token=ANRR26PUSDXUDJHKQGBHHI27JSXJM" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200827142041106"></p>
</li>
<li><p><strong>一个程序必须至少有一个输出</strong>。System是Java类库中的一个类，out是System类中的一个对象，println(或print)是out对象的一个方法。</p>
</li>
</ol>
<h2 id="变量和数据"><a href="#变量和数据" class="headerlink" title="变量和数据"></a>变量和数据</h2><ol>
<li><p><strong>变量名可以是$开头</strong>：Java 的标识符由字母、数字、_和$组成，长度不限，但实际命名不宜过长。<br>标识符的第一个字符必须为字母、 “_”或 “$” 。标识符区分大小写。<strong>不能数字开头。</strong></p>
</li>
<li><p><strong>Java严格区分大小写。</strong>变量名、对象名、方法名、包名等标识符全部采用小写字母；若标识符由多个单词构成，则首单词小写，其后单词的首字母大写，其余字母小写。如getAge。<br>类名首字母大写，常量名全部字母大写，关键字全部小写。</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200827142930953.png?token=ANRR26I7OMDJXI57VDIXFMC7JSXJ2" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200827142930953"></p>
<p>注意数组、接口和类叫做“引用类型“，<strong>没有一种类型叫“实型”</strong></p>
<p>其实String可以骑墙，在这里先视作引用类型。</p>
</li>
<li><p>Java的long型占8个字节，表示方式为数字后加L或者l。float也只占4个字节，double8个。</p>
</li>
<li><p>八进制：开头是0；十六进制：0X或0x为前缀。</p>
</li>
<li><p><strong>关于“float精度”</strong>：<a href="https://blog.csdn.net/albertsh/article/details/92385277" target="_blank" rel="noopener">https://blog.csdn.net/albertsh/article/details/92385277</a></p>
<p>(±)a.b x 10^c</p>
<p><code>float</code>的存储正是将4字节32位划分为了3部分来分别存储正负号，小数部分和指数部分的：</p>
<ol>
<li>Sign（1位）：用来表示浮点数是正数还是负数，0表示正数，1表示负数。</li>
<li>Exponent（8位）：指数部分。即上文提到数字c，但是这里不是直接存储c，为了同时表示正负指数以及他们的大小顺序，这里实际存储的是c+127。</li>
<li>Mantissa（23位）：尾数部分。也就是上文中提到的数字b。</li>
<li>通常意义上float精度在6-7，double在16-17</li>
</ol>
</li>
<li><p><strong>科学计数法</strong>   2.5E4:  2.5称为尾数，4称为阶码</p>
</li>
<li><p>char类型：<strong>占两个字节</strong>，16位。表示方式：’a’，’\u0043’</p>
</li>
<li><p>boolean类型：占一个字节，和C++不同，不能与数值0或1等同</p>
</li>
</ol>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ol>
<li><p>单目运算符的优先级高于双目运算符，而在双目运算符中，先*、/、%运算，再+、-运算。但是当x=y–时，y先传递值，后–。n++：取n值作为表达式 n++ 的值；n = n + 1</p>
</li>
<li><p><strong>字符类型操作数的比较依据是其Ascii码值</strong>，如’a’&lt;‘d ‘。字符串只能用==或者！=，不能比大小；boolean类的也是。Ascii码的顺序：数字-大写-小写；==和！=优先级低</p>
</li>
<li><p>运算有优先级（后面贴了表格），括号-单目-乘除余加减-不相等相等比较-赋值</p>
<p>算术关系没逻辑，给了条件才赋值</p>
</li>
<li><pre><code>System.out.println(&#39;A&#39;+1);//65
System.out.println(&#39;A&#39;);//A</code></pre></li>
<li><p>关于数据类型转化级别：<img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200827150535730.png?token=ANRR26JSRN733ZMG5KJRBGS7JSXKQ" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200827150535730"></p>
<p>Char类型可自动转换成int类型，其值为字符的Ascii码值（隐式）<br>而int类型到Char类型需要经过强制类型转换（强制）</p>
</li>
<li><p>java.lang.Math类提供方法来执行基本数学函数的运算。round()方法:返回最接近操作数的整数<br>对于正数而言就是四舍五入取整，对负数时&gt;0.6的小数向绝对值更大的方向舍。</p>
<p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200827151117847.png" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200827151117847"></p>
<p>random()方法:返回一个double型随机数，此方法不带参数<br>随机数范围：<strong>大于等于</strong>0.0且小于1.0<br>产生固定范围内的随机整数：<br>(Int)((上界-下界+1)<em>Math.random()+下界)<br>int a=(int)(Math.random()</em>10);    //大于等于0小于10的随机整数<br>int b= (int)(89*Math.random()+10);//大于等于10小于99的随机整数（如果是要两位数应该写到90）</p>
<p>Math.exp(int n)返回e的n次幂</p>
<p>重要常量：Math.PI 和 Math.E</p>
</li>
<li><p>和System类似，Scanner也是一个类（在import java.util.Scanner ; 或 import java.util.<em>; ），需要先创建实例化对象Scanner in=new Scanner(System.in); 然后用in.next来读取键盘输入，需要注意，*</em>并没有in.nextString，也没有nextChar，只有nextline(),nextInt(),nextDouble(),nextFloat() 。光一个next到空格就停止。**</p>
</li>
<li><p><code>;</code>也是一个语句，是空语句。</p>
</li>
</ol>
<h2 id="三大基本结构和部分简单算法"><a href="#三大基本结构和部分简单算法" class="headerlink" title="三大基本结构和部分简单算法"></a>三大基本结构和部分简单算法</h2><ol>
<li><p>任何程序有三种基本的结构：顺序、分支、选择。这是基本的结构。</p>
</li>
<li><p>java分支：if：二选一（不是多选一）  if扩展、嵌套、switch：多选一</p>
</li>
<li><p>闰年判断：<code>year%4==0 &amp;&amp; year%100!=0 || year%400==0</code></p>
</li>
<li><p><strong>else总与离他最近的if配对。</strong></p>
</li>
<li><p><strong>switch语句判断数据类型可以是short，int，char，byte，不可以是浮点数和long</strong>。如果没有break，执行后续所有case语句中的语句块，default也执行。default的位置不影响。</p>
<pre><code class="java">public class Pass {
    public static void main(String[] args) {
        char i = &#39;2&#39;;
        switch (i) {
            default:
                System.out.println(&quot;default&quot;);
            case &#39;2&#39;:
                System.out.println(&quot;2&quot;);
            case &#39;3&#39;:
                System.out.println(&quot;3&quot;);
            case &#39;4&#39;:
                System.out.println(&quot;4&quot;);
                break;//这句有无不影响结果
        }
    }
}//输出234

public class Pass {
    public static void main(String[] args) {
        char i = &#39;2&#39;;
        switch (i) {
            case &#39;2&#39;:
                System.out.println(&quot;2&quot;);
            case &#39;3&#39;:
                System.out.println(&quot;3&quot;);
            case &#39;4&#39;:
                System.out.println(&quot;4&quot;);
            default:
                System.out.println(&quot;default&quot;);
        }
    }
}//输出234default</code></pre>
</li>
</ol>
<ol start="6">
<li><p>循环的两种类型：计数控制和事态控制。</p>
</li>
<li><p>continue：是跳过当前这轮循环，剩下的语句全部跳过，不是只跳一个</p>
<pre><code class="java">public class Pass {
    public static void main(String[] args) {
        int i = 0;
        int s = 0;
        while (i &lt; 5) {
            i++;
            System.out.print(&quot;\nthis is &quot; + i+&quot;:  &quot;);
            System.out.print(&quot;1&quot;);
            if (i == 3) continue;
            System.out.print(&quot;2&quot;);
            System.out.print(&quot;3&quot;);
        }
    }
}
//this is 1:  123
//this is 2:  123
//this is 3:  1
//this is 4:  123
//this is 5:  123</code></pre>
</li>
</ol>
<ol start="8">
<li><p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200829090024682.png?token=ANRR26KLCH7NX3OWBNQAVZK7JSXLC" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200829090024682"></p>
</li>
<li><p>水仙花数：三位数各位数字立方和等于它本身。</p>
<p>完数：因子的和与它本身相等。</p>
<pre><code class="java">public class PerfectNumber {
    public static void PerfectN(){

        for(int a=2;a&lt;=1000;a++){
            int s=a;
            for(int i=1;i&lt;a;i++){
                if(a%i==0){
                    s=s-i;
                }
            }
            if(s==0){
                System.out.println(&quot;输出完数：&quot;+a);
            }
        }

    }
    public static void main(String[] args){
        PerfectN();
   }
}
</code></pre>
</li>
<li><p>Java叫方法，只能在类class中声明</p>
</li>
<li><p>void的标准含义：<strong>方法没有返回值</strong>。里面包含变量声明，语句，返回语句</p>
</li>
<li><p>在JAVA中只有值传递</p>
</li>
<li><p>递归，关键的是递归公式和递归出口</p>
</li>
<li><p>汉诺塔：</p>
<p>若用A、B和C表示3根针，将n个金片由A针移动到C针，步骤如下：<br>将A上的n-1个金片借助C针移动到B针上。<br>将A针上剩下的一个金片由A针移动到C针上。<br>将最后剩下的n-1个金片借助A针由B针移动到C针上。</p>
<pre><code class="java">static void  hanoi( int n , char  a ,  char b  ,  char c ) 
{
 if (n = = 1) 
     moves(a, c);//如果只剩一片，直接移动
 else//还剩很多片
     hanoi(n - 1, a, c, b);//先把n-1片移动好，从a借助c放到b上
     moves(a, c);//然后把最后一片移动
     hanoi(n - 1, b, a, c);//再把n-1片移动到这最后一片上去，从b借助a放到c上。
 }
</code></pre>
</li>
<li><p>保留2位小数：<code>(int)(a*100+0.5)/100.0</code></p>
<pre><code class="java">    import java.math.BigDecimal;
    import java.text.DecimalFormat;
    import java.text.NumberFormat;
    public class format {
        double f = 111231.5585;
        public void m1() {
            BigDecimal bg = new BigDecimal(f);
            double f1 = bg.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();
            System.out.println(f1);
        }
        /**
         * DecimalFormat转换最简便
         */
        public void m2() {
            DecimalFormat df = new DecimalFormat(&quot;#.00&quot;);
            System.out.println(df.format(f));
        }
        /**
         * String.format打印最简便
         */
        public void m3() {
            System.out.println(String.format(&quot;%.2f&quot;, f));//会四舍五入
        }

        public static void main(String[] args) {//这个博主写的实际上是错的，仅供参考方法。
            //他的方法没有写static，main是无法调用的。
            format f = new format();
            f.m1();
            f.m2();
            f.m3();
        }
    }</code></pre>
</li>
<li><p>关于length和length():<a href="http://www.itwanger.com/java/2019/12/08/java-array-string-length.html" target="_blank" rel="noopener">http://www.itwanger.com/java/2019/12/08/java-array-string-length.html</a></p>
<p>数组的长度是可以确定的，直接用一个属性length去表示就可以了。但对于String来说，length的源码是</p>
<pre><code class="java">    /**
     * Returns the length of this string.
     * The length is equal to the number of Unicode
     * code units in the string.
     */
    public int length() {
        return value.length;//因为value是一个private值，所以需要一个方法作为接口。
    }</code></pre>
</li>
<li><p>计算单词个数：要注意abandon       （多个空格）after这种情况。因为结尾没有空格，那么就计算空+有的结构，不要计算有+空的结构。</p>
<pre><code class="java">import java.io.IOException;
import java.util.Scanner;

public class Pass {
    public static void main(String[] args) {
        int ri, repeat,count, word,i;
        String line;
        char c;
        Scanner in=new Scanner(System.in);
        repeat=(in.nextLine()).charAt(0)-&#39;0&#39;;
        for(ri=1; ri&lt;=repeat; ri++){
            line=in.nextLine();
            word=0;count=0;
            for(i=0;i&lt;line.length();i++)
            {
                if(line.charAt(i)!=&#39; &#39;)
                { if(word==0)
                    count++;
                    word=word+1;
                }
                else word=0;//用来标记是不是已经没单词了
            }
            System.out.println( count);
        }
    }
}

</code></pre>
</li>
</ol>
<pre><code>public class Pass {
    public static void main(String[] args) {
        String a[] = &quot;111 22   33 4  5&quot;.split(&quot;\\s+&quot;);
        System.out.println(a.length);
    }
}//\s表示空的字符，换行、tab。space等，+表示一个或多个
```</code></pre><ol start="18">
<li><p>nextint和nextline在一起用会出问题，<strong>因为nextint之后光标不略过回车</strong>。参考<code>repeat = in.nextLine().charAt(0)-&#39;0&#39;;</code></p>
</li>
<li><p>java数组数据类型要相同。数组必须进过申明和初始化，确定数组名、维数和元素数据类型才能使用。各元素的存数空间是连续的。</p>
<p><strong>二维数组初始化时，可以每行单独进行，允许各行元素数目不同。</strong></p>
<p>数组的复制：可以用循环语句，<strong>也可以直接a=b。</strong></p>
<pre><code class="java">
public class Pass {
    public static void main(String[] args) {
        int a[] = {1, 2, 3};
        int b[] = {1, 2, 3, 4, 5};
        System.out.println(&quot;before:&quot;);
        for (int i = 0; i &lt; a.length; i++) {
            System.out.print(a[i]);//123
        }
        System.out.println();
        for (int i = 0; i &lt; b.length; i++) {
            System.out.print(b[i]);//12345
        }
        System.out.println();

        b = a;
        System.out.println(&quot;after:&quot;);
        for (int i = 0; i &lt; b.length; i++) {
            System.out.print(b[i]);//123
        }
        System.out.println();

        a[2] = 100;
        System.out.println(&quot;after2:&quot;);
        for (int i = 0; i &lt; b.length; i++) {
            System.out.print(b[i]);
            //12100,说明直接a=b传递的是地址，且b的大小也会和a一样。
        }
    }
}</code></pre>
</li>
<li><p>选择法：每次都选当前数组最小的数，然后交换一次，用一个pos变量来记录现在这个“最小数”的位置。 </p>
</li>
<li><p>杨辉三角：a[i][j]=a[i-1][j-1]+a[i-1][j];</p>
</li>
<li><p>数组作为参数，形参必须有[ ]，实参可以没有。数组名传递地址，数组元素做参数传递的是值。</p>
</li>
<li><pre><code class="java">char a[]={&#39;C&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;};
System.out.println(a);//可以输出China</code></pre>
</li>
<li><pre><code class="java">import java.io.IOException;
import java.util.Scanner;

public class Pass {
    public static void main(String[] args) {
        String a = &quot;hello&quot;;
        String b = a;
        String c = &quot;&quot;;
        c = a;
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println();
        a = &quot;Hello&quot;;
        System.out.println(a);//Hello
        System.out.println(b);//hello,是浅拷贝
        System.out.println(c);//hello
    }
}
//https://www.cnblogs.com/genggeng/p/10065885.html</code></pre>
<p>浅拷贝只进行值的传递，本质上还是两份不同的数据。</p>
<p>对于数组、某个类的实例化对象，这都属于引用数据类型，进行引用传递，也就是地址。这时它们是指向同一块内存的。</p>
</li>
<li><p>String的函数： indexOf返回的index是从0开始数的。indexOf（str，in）返回从第in个开始，str首次出现的位置。</p>
<pre><code class="java">public class Pass {
    public static void main(String[] args) {
        String a = &quot;abababababab&quot;;
        System.out.println(a.indexOf(&quot;ab&quot;, 2));//2,是从整个字符串算的下标。
    }
}</code></pre>
<p>substring（in1，in2）返回两个in之间的子字符串，in2可以省略。</p>
<pre><code class="java">public class Pass {
    public static void main(String[] args) {
        String a = &quot;abcdefg&quot;;
        System.out.println(a.substring(0, 2));//ab,包括0不包括2
    }
}</code></pre>
<p>equalsIgnoreCase（str）忽略大小写的比较。</p>
<p>compareTo(str) 与str进行比较。大正小负，返回第一个不相等的差值，<strong>不是下标</strong>。</p>
<p>String.valueOf(数据)，把数据<strong>变成</strong>string类型。变成其他类型：</p>
<p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200830101458679.png?token=ANRR26P5DLTT5MJNWE5ABRS7JSXLY" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200830101458679"></p>
</li>
</ol>
<h2 id="OOP部分"><a href="#OOP部分" class="headerlink" title="OOP部分"></a>OOP部分</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>面向对象的程序设计认为：程序由类（对象）组成。</p>
</li>
<li><p>类属于引用数据类型，因此在声明时系统不会分配空间，需要手动new一个空间。当使用new运算符实例化一个对象时，Java做两件事：系统为对象创建内存区域，自动调用构造方法初始化成员变量。程序不能直接调用构造方法。New实例化一个对象时，自动调用；无构造方法，生成一个无参的默认构造方法，使用默认值初始化对象的成员变量：数值型-0；布尔型-false ;字符型’\0’,字符串型null。参数个数和参数类型都能用来区分构造方法的重载。</p>
</li>
<li><p><strong>一个类就有一个.class文件，能被运行的是有main方法的类（主类）。</strong></p>
</li>
<li><p><strong>new运算符实例化对象</strong><br>过程：系统为对象分配所需的存储空间<br>但内存空间有限，不能存放无限多的对象<br>为此，Java提供了资源回收机制，自动销毁无用对象，回收其所占用的存储空间<br>如需主动释放对象，或在释放时执行特定操作，则在类中可以定义 finalize() 方法：</p>
<pre><code class="java">    public void finalize()
    {
      方法体；
     }  </code></pre>
</li>
<li><p>封装性是面向对象的核心特征之一<br>类的封装（对设计者而言）包含2层含义<br><strong>将数据和对数据的操作组合起来构成类，类是一个不可分割的独立单位，类是Java程序的构成。</strong>类中包括：<br>数据、成员变量 、对象的属性<br>对数据的操作、成员方法 、对象所能完成的功能<br><strong>类中既要提供与外部联系的接口，同时又要尽可能隐藏类的实现细节。</strong><br>具体方法就是为类及成员变量和成员方法设置合理的访问权限<br>对于设计者而言,封装使模块之间的耦合和交差大大减少,降低了程序开发的复杂性<br>对于使用者，不需要关心类内部的细节，只要知道：<br>哪些类可以选择，类的功能,即提供了哪些方法可使用</p>
</li>
</ol>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ol>
<li><table>
<thead>
<tr>
<th><strong>访问控制</strong></th>
<th><strong>本类</strong></th>
<th><strong>同一包中的类</strong></th>
<th><strong>其他包中子类</strong></th>
<th><strong>其他包中的类</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>public</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>private</strong></td>
<td></td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td><strong>protected</strong></td>
<td></td>
<td></td>
<td></td>
<td>×</td>
</tr>
<tr>
<td><strong>缺省</strong></td>
<td></td>
<td></td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>缺省就是这个包里面都能访问；proteted是其他包的其他类不能访问。真事儿多。</p>
</li>
<li><p>声明一个类可使用的权限修饰符：public、缺省，<strong>不能使用：private、protected</strong></p>
</li>
<li><p><strong>Java的类中可以包含两种成员：实例成员和类成员</strong><br><strong>实例成员属于对象</strong><br>包括实例成员变量和实例成员方法<br>必须通过对象访问实例成员变量，调用实例成员方法<br>实例方法使用变量是不是static都行</p>
<p><strong>类成员属于类</strong><br>包括类成员变量和类成员方法，<strong>申明时用static修饰</strong><br>通过对象可以引用类成员变量和类方法<br>也可以通过类名可直接访问类成员变量，调用类成员方法<br>没有创建对象，也可以引用类成员<br>类成员变量在该类被加载到内存时就分配了存储空间，是共享的。<br>类成员方法使用变量只能访问同为static的变量，要调用实例成员方法时也必须通过创建对象才行。</p>
</li>
<li><p>逆序数：</p>
<pre><code class="java">while(number&gt;0){
            digit=number%10; //分离出个位数字
            a=a*10+digit;    //形成当前的逆序数
            number=number/10;
      }</code></pre>
</li>
<li><p>10转2</p>
<pre><code class="JAVA">      String t=&quot;&quot;; //保存二进制数
      do {
          t=n%2+t;  //n除2后的余数拼接到t的前面
          n=n/2;  //获得除2后的商
      }while(n&gt;0);</code></pre>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li><p>继承关键字：extend<strong>s</strong>  <strong>注意有s</strong>。被继承的叫做superclass或baseclass或parentclass，新的类称为derived class，或者subclass，childclass。</p>
</li>
<li><p><strong>所有类都直接或间接的继承自object。</strong>所以如果没有指定，就默认继承它；object类有许多成员和方法，比如hashcode（）获取hash码，equal<strong>s</strong>（）检测相等。</p>
</li>
<li><p><strong>子类不继承父类构造方法。</strong>保护和私有的成员也都继承，但是私有的变量不能直接访问。</p>
</li>
<li><pre><code class="java">public Ctor(){
    this(6);//是可以用this指代构造函数的
}
public Ctor(int a){
    this.a=a;
}</code></pre>
</li>
<li><p>多态性：指同一名字的方法有多种实现。他们根据参数或调用对象进行区分。<strong>在oop中表现为，重载类的方法、子类覆盖父类方法。</strong>重载表现为形参的<strong>个数、类型和顺序</strong>不同。方法的<strong>返回值和参数名称</strong>不是判断依据；覆盖是指子类定义了父类中的同名方法。表现为父类与子类之间方法的多态性。寻找对应的执行方法时，先从当前类开始，如果没有符合的再看上一级。</p>
</li>
<li><p><strong>注意，用final修饰的类不能被继承（固定作用|已经完美）<br>用final修饰的成员方法不能被覆盖<br>用final修饰的成员变量不能被修改（编译错误）。</strong></p>
</li>
</ol>
<p>   final关键字：当用final修饰一个类时，表明这个类不能被继承（extend）。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>   <a href="https://www.cnblogs.com/dolphin0520/p/3736238.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3736238.html</a></p>
<p>   下面这段话摘自《Java编程思想》第四版第143页：</p>
<p>   　　“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“</p>
<p>   　　因此，如果只有在<strong>想明确禁止 该方法在子类中被覆盖</strong>的情况下才将方法设置为final的。</p>
<p>   　　注：<strong>类的private方法会隐式地被指定为final方法。</strong></p>
<p>   修饰变量是final用得最多的地方.对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改,<strong>但是它指向的对象的内容(如一个对象的成员变量）是可变的</strong>；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>
<pre><code class="java">   public class Pass {
       public static void main(String[] args) {
           final String a = &quot;hello&quot;;
           String b = &quot;hello&quot;;
           String c=&quot;hello2&quot;;
           System.out.println(&quot;a+2=&quot; + (a + 2));//hello2
           System.out.println(&quot;b+2=&quot; + (b + 2));//hello2
           System.out.println(&quot;a==c is &quot;+(a+2==c));//true
           System.out.println(&quot;b==c is &quot;+(b+2==c));//false
       }
   }
   //当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用</code></pre>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ol>
<li><p><strong>接口是一组常量+抽象方法，包是一组类和接口。包&gt;接口。</strong></p>
</li>
<li><p>抽象类是供子类继承、但不能创建实例的类。关键字是abstract:</p>
<pre><code class="java">[权限修饰符] abstract class   类名{
    成员变量声明
    [权限修饰符] abstract  返回类型  方法名(参数表);
} </code></pre>
</li>
<li><p>抽象类可以有不抽象的方法，反之不行。<br>即使抽象类不包含抽象方法也不能被继承。<br>子类必须给出所有具体实现。</p>
</li>
<li><p>相比之下<strong>接口的要求更严格，只能定义public的抽象方法和静态的、公有常量</strong>。接口提供了方法声明与实现相分离的机制，实现相同接口的多个类表现出相同的行为模式，每个实现接口的类可以根据各自要求，给出抽象方法的具体实现。</p>
<pre><code class="java">[访问权限] interface  接口名 [extends  父接口名] {
    成员变量表(常量)
 成员方法列表（抽象）
}</code></pre>
</li>
<li><p>接口的权限只能是public和缺省，方法必须是<strong>public abstract</strong>所以可以省略，常量必须是<strong>public static final</strong>所以也可以省略，接口<strong>允许没有父接口</strong>，也就是没有最高层（类有最高层、必须有父接口Object）</p>
<pre><code class="java">class 类名 [extends 父类名] implements 接口名列表{
     类体
}
说明
一个类可以实现多个接口，各个接口之间用逗号分开
该类必须要实现接口中所有的抽象方法，即使本类中不使用的抽象方法也要实现
对不使用的抽象方法如何实现:
不需要返回值的方法:空方法实现,即方法中没有语句
有返回值的方法:在方法中使用默认值返回，如0
实现抽象方法，需指定访问权限为public</code></pre>
</li>
<li><p>接口和抽象类比较：</p>
<p><strong>相同点</strong><br>都不能被实例化<br><strong>不同点</strong><br>一个类只能继承一个抽象类，是单继承；一类可以实现多个接口,具有多重继承功能<br>抽象类是类,类中可以包含成员变量、构造方法、抽象方法和方法；而接口是<strong>一组抽象方法和常量的组合</strong>。<br>抽象类中的成员具有和普通类中的成员一样的访问权限，而接口中成员访问权限只能是public。</p>
</li>
</ol>
<h3 id="import-package"><a href="#import-package" class="headerlink" title="import/package"></a>import/package</h3><ol>
<li><p>一个源程序导入包中的类或接口后，引用该类和接口时，包名可省略，Import语句在源程序中必须位于其他类或接口申明之前。</p>
</li>
<li><p>一个Java的源程序文件（.java文件）中可包含：</p>
<pre><code class="java">[package  包名 ]                 // 声明所在包 
[import 包名.类名 |包名.接口名]  //导入其它包中的类或接口，  
                                             “|”表示2者选1
[ public ] class | interface     //声明类或接口</code></pre>
<p>一个源程序文件中，最多只能有<strong>一条package</strong>语句，并且必须是第一条语句。一个源程序文件中，可以有<strong>多条import</strong>语句，并且必须位于其它类或接口声明之前。一个源程序文件中，可定义多个类或接口，但只能定义一个<strong>public类或public接口，并且该类或接口名与文件名相同</strong>。</p>
</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ol>
<li><p><strong>异常：程序运行过程中出现的非正常现象。</strong>Java提供了异常处理机制：异常类，用来<strong>描述和处理</strong>异常，每个异常类只反映一类运行错误。异常情况分为Exception和Error两大类，Error是内部系统错误，只能关闭程序，Exception可在程序中捕获和处理。</p>
<p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200831105153693.png?token=ANRR26J33HULFCPC5M422D27JSXMS" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200831105153693"></p>
</li>
<li><p>Exception的处理方法：</p>
<ol>
<li><p>try…catch…finally来对异常进行捕获和处理。</p>
<pre><code class="java">public class Exception1 {
  public static void main(String args[])      {
      try {
          int a[]={1,2,3,4,5}, sum=0;
          for (int i=0; i&lt;=5; i++) 
        sum=sum+a[i];
          System.out.println(&quot;sum=&quot;+sum);
          System.out.println(&quot;Successfully! &quot;);
       }//异常类名1对应的异常处理代码, 若干条catch捕获各类异常，一旦出现，终止try代码块运行，自动跳转到异常所对应的catah块中，执行其中的代码
     catch (ArrayIndexOutOfBoundsException e){//catch (异常类名2   异常对象名2)
          System.out.println(&quot;ArrayIndexOutOfBoundsException  detected&quot;);
      }
     finally    {
         System.out.println(&quot; Programm Finished! &quot;);
      }//Finally代码块是个可选项，如果有，无论异常是否发生， Finally块中的代码最终必定执行
 }} 
</code></pre>
</li>
<li><p>throw语句和throws选项抛出异常。通常异常是系统自动捕获的，也可以通过throw语句自己抛出而不捕获。<code>throw  new 异常类名（信息）</code>异常类名为系统异常类名或用户自定义的异常类名，“信息”是可选信息。若有该信息，toString()方法的中将增加该信息内容,toString()方法用于返回系统给出的异常信息.</p>
<pre><code class="java">//捕获多个异常
public class Exception2
{
  public static int Sum(int n) {
    int s = 0;
    int x[ ]=new int[n];
    for (int i=0; i&lt;=n; i++) {  
           if(i==n)  throw new ArrayIndexOutOfBoundsException(&quot;下标越界&quot;);
           x[i]=i;
           s = s +x[i];}  
    return s;    
  }
</code></pre>
<p>为了明确一个方法不捕获异常，也可在声明该方法时，使用throws选项，抛出该类异常。格式为：</p>
<pre><code class="java">[修饰符] 返回值类型 方法名[（参数表）] throws 异常类名{
……
}</code></pre>
</li>
</ol>
</li>
<li><p>自定义异常类，可以继承Exception。</p>
</li>
</ol>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><ol>
<li><p>Java的输入输出，以流的方式处理。如字节流、字符流等。特点是都按照数据序列的顺序。InputStream和OutStream是java处理字节流的基本类，Reader和Writer是处理字符流的基本类。<strong>都包含在io包中。</strong></p>
</li>
<li><p>Java系统预先定义2个流对象分别<strong>表示标准输入、输出设备：</strong></p>
<ol>
<li><p>System.in   标准输入设备：键盘</p>
<p>它是InputStream类的一个对象<strong>（不是类）</strong></p>
<pre><code class="java">import java.io.*;// 声明导入IO包
public class StandardIn1 {   
    public static void main(String[] args) throws IOException{
      //使用read()时，应对IOException类异常进行捕获或抛出
      char c;
      System.out.println(&quot; 输入一个字符&quot;);
      c=(char)System.in.read();   //使用read()方法从键盘读入1个字符
      System.out.print( &quot;输入的字符是：&quot;+c); 
    }
}</code></pre>
<p>使用bufferedReader（Reader类的子类）的readLine（）可以从键盘键入字符串，一次读一行。</p>
<pre><code class="java">import java.io.*;
public class StandardIn3 {
  public static void main(String[] args)    throws IOException {
    InputStreamReader iin=new InputStreamReader(System.in);
    BufferedReader bin =new BufferedReader(iin);
    String s;  
    int i; 
    s=bin.readLine();              //输入一个字符串
    i=Integer.parseInt(bin.readLine());    //输入一个整数
           System.out.println(&quot;输入的字符串:&quot;+s);         
            System.out.println(&quot;输入的整数:&quot;+i);         
   }
}</code></pre>
<p>Scanner类是SDK1.5新增的一个类，使用该类创建的对象可扫描键盘的输入 ，即程序直接读取键盘输入的数据.</p>
<pre><code class="java">Scanner in=new Scanner(System.in);</code></pre>
<p>命令行输入字符串数据。</p>
</li>
<li><p>System.out  标准输出设备：显示器，属于PrintStream类。使用print和println方法来输出各类数据。printf（）是JDK1.5才开始支持。格式说明的形式：</p>
<pre><code>%  -   m.n  格式字符 </code></pre><p>%：表示格式说明的起始符号，不可缺<br>-：有”-”号表示左对齐输出，如省略表示右对齐输出。<br>m.n：m指域宽，即对应的输出项在输出设备上所占的宽度（列数）。n指精度，用于说明输出的实型数的小数位数。</p>
<pre><code class="java">目前printf支持以下格式： 
%c       单个字符 
%d       十进制整数 
%f        十进制浮点数 
%o        八进制数 
%s        字符串 
%u        无符号十进制数 
%x        十六进制数 
%%       输出百分号%

public class Pass {
    public static void main(String[] args) {
        int [ ][ ] a=new int[4][4];
        int i,j,s=0;
        for(i=0;i&lt;4;i++){
            for(j=0;j&lt;4;j++){
                a[i][j]=(int)(Math.random()*9+1);
                s+=a[i][j];
                System.out.printf(&quot;%-4d&quot;,a[i][j] ); }
            System.out.println();
        }
        System.out.printf(&quot;%6.2f&quot;, s/16.0);

    }

}</code></pre>
<p>输出：<img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200831131350058.png?token=ANRR26OTVQQBIM4KA7WXYQS7JSXNE" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200831131350058"></p>
<p><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/wps1.jpg" srcset="/silmont2000.github.io/img/loading.gif" alt="img"></p>
</li>
</ol>
</li>
<li><p>Java进阶：</p>
<ol>
<li><p>Java应用程序要分为Application和Applet两种。Application可以直接独立运行，Applet必须借助浏览器。它集成java.applet.Applet类，嵌入HTML，通常置于服务器端，客户端下载之后通过浏览器运行。<img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200831131634655.png?token=ANRR26LGT6UK2MO6U7WRK227JSXNS" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200831131634655"></p>
<pre><code class="java">import java.awt.*;      //一个Applet程序的例子
import java.applet.*;
public class Drawing extends Applet{
    public void paint(Graphics g){
        g.setColor(Color.red);
        g.drawString(&quot;我一边喝咖啡，一边学Java&quot;, 5, 60);
        g.setColor(Color.blue);
        g.drawString(&quot;我学得很认真&quot;, 5, 100);
    }
}
//可以在Eclipse中直接运行
//可以嵌入到HTML文件中，在浏览器中运行
&lt;html&gt;
&lt;applet code=Drawing.class height=100 width=300&gt;
&lt;/applet&gt;
&lt;/html&gt;

//在命令行窗口，用appletviewer.exe程序运行，格式：
//appletviewer  HTML文件名.html</code></pre>
</li>
<li><p>多线程机制：可以同时运行多个执行体。</p>
<p>主线程是main对应的线程。要实现多线程要在主线程中创建新的线程（Thread类和它的子类来表示）每个线程要经历由“新生就绪运行阻塞死亡”五种状态，线程从新生到死亡的状态变化过程称为生命周期。 <img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/image-20200831132017018.png?token=ANRR26KC24SNB3BIIQREK2S7JSXOO" srcset="/silmont2000.github.io/img/loading.gif" alt="image-20200831132017018"></p>
<ol>
<li><p>通过Tread类继承实现：</p>
<pre><code class="java">class Thread1 extends Thread{//是一个类
     String s;
      int m, count=0;
      Thread1(String ss, int mm) { //构造函数
          s=ss; 
         m=mm; 
       }
    public void run() {//运行时方法的覆盖
        try{
              while (true){
                   System.out.print(s); 
                sleep(m); 
                   count++;
                if (count &gt;= 20) break;      
            }
              System.out.println(s+&quot;finished !&quot;);
          }
        catch(InterruptedException e)   {return;}
    }
}

public static void main(String args[]) {
    Thread1 threadA = new Thread1(&quot;A  &quot;, 50);
    Thread1 threadB = new Thread1(&quot;B  &quot;, 100);
    threadA.start();
    threadB.start();
}    </code></pre>
</li>
<li><p>也可以通过实现Runnable接口的类来实现。（没有例子）</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="彩蛋-知识点表和提示"><a href="#彩蛋-知识点表和提示" class="headerlink" title="彩蛋-知识点表和提示"></a>彩蛋-知识点表和提示</h1><table>
<thead>
<tr>
<th>A</th>
<th>数据的定义</th>
<th>01</th>
<th>基本数据类型：整型、实型和字符型、布尔型常量各种表示形式的整数、实数、字符、布尔(true,false)常量和字符串常量，符号常量（final）的定义和使用。包括整数的十进制、八进制和十六进制的表示形式、长整型常量和无符号型常量的表示形式，实数的浮点表示法和科学记数法，字符的转义序列等</th>
<th>Final定义的数据不能修改十进制正常的数，八进制是0开头，十六进制是0X或0x浮点表示法：float，4字节，32位，精度是7到8位Double，8字节，64位，精度是16到17位。<a href="https://blog.csdn.net/a327369238/article/details/52354811科学计数法：4E3表示4*10^3不是e^3。1e-49，如果是float打印，会变成1.0E-49而且E之前的数字可以不是只有一位整数位的。100l，表示long" target="_blank" rel="noopener">https://blog.csdn.net/a327369238/article/details/52354811科学计数法：4E3表示4*10^3不是e^3。1e-49，如果是float打印，会变成1.0E-49而且E之前的数字可以不是只有一位整数位的。100l，表示long</a> 类型，</th>
</tr>
</thead>
<tbody><tr>
<td>02</td>
<td>变量的概念、定义和初始化；</td>
<td>java变量包含静态变量(static Variable)、成员变量()和局部(local Variable )变量三种。其实，也可以说两种，静态变量和成员变量都是全局变量(Global Variable)，只是成员变量是动态的,还有就是，静态变量的生存周期是由类决定的，是在加载类文件时初始化的；而成员变量则是在类中没有用static修饰的变量，它的生存周期是由对象决定的，是在new 一个对象时初始化的。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>03</td>
<td>基本运算和表达式：（含对应的表达式语句）包括算术运算（含自增、自减操作）、关系运算、逻辑运算、<strong>*\</strong>位运算、****条件运算、赋值运算等。熟练掌握运算符的功能熟练掌握运算符的优先级和结合方向熟练掌握隐式类型转换和强制类型转换</td>
<td><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/wps2.jpg" srcset="/silmont2000.github.io/img/loading.gif" alt="img"> <strong><em>\</em>括号 -&gt; 单目（非、正负、自增自减） -&gt; 乘除取余加减 -&gt; 位移 -&gt;比较相等**</strong>异或运算符是用符号“^”表示的，其运算规律是： 两个操作数的位中，相同则结果为0，不同则结果为1。低级变量可以直接转换为高级变量（隐式）。String-&gt;其他： Integer.parseInt(（str）;其他 -&gt;string：String.valueOf( ).</td>
<td></td>
<td></td>
</tr>
<tr>
<td>04</td>
<td>系统提供的方法（函数）及包含方法的表达式。（含对应的表达式语句）Math类：PI、abs、sin、cos、sqrt、pow、exp、log、log10、random、round等</td>
<td>Random()返回[0,1)的随机double值。Exp：e的多少次方返回二位数：（int）（random（）<em>90）+10；返回m，n之间的数（包括m不包括n）（int）（random()</em>(n-m)）+m round()方法:返回最接近操作数的整数 对于正数而言就是四舍五入取整，对负数时&gt;0.6的小数向绝对值更大的方向舍。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>编程基础</td>
<td>01</td>
<td>第1章中的其它Java概念结构化程序设计方法（如逐步求精法）良好的程序设计风格（如程序模块化、加注释、缩进的书写格式）文件扩展名等概念</td>
<td></td>
</tr>
<tr>
<td>02</td>
<td>输入：<strong>*\</strong>命令行参数；*<strong><em>Scanner类：nextInt()、nextShort()、nextLong()、nextDouble()、nextFloat()、next()、nextLine()等；BufferedReader类：read()、readLine()；</em></strong>*<em>JoptionPane类中的showInputDialog方法***</em>输出：System.out.print()/println()/<strong>*\</strong>printf()*<strong><em>等</em></strong>*<em>JoptionPane类中的showMessageDialog方法***</em>数据类型转换：Integer.parseInt()、Long.parseLong()、Short.parseShort()、Float.valueOf()、Double.valueOf()、String.valueOf()等</td>
<td><img src="https://raw.githubusercontent.com/silmont2000/BlogPic/master/img/wps3.jpg" srcset="/silmont2000.github.io/img/loading.gif" alt="img"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>03</td>
<td>选择控制语句(if、switch，含break)，复合语句</td>
<td>无break的时候执行的是case语句，default也要执行。Default放的位置是无所谓的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>04</td>
<td>循环控制语句(for、while、do—while，含break和continue)，空语句</td>
<td>Continue是跳过当前循环</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>方法（函数）</td>
<td>01</td>
<td>空类型的声明（定义）和使用；main方法与其他方法之间的关系；方法定义的格式；return语句；方法的参数（形式参数和实在参数）及参数传递；方法的返回值；方法调用；嵌套调用和递归调用的概念；</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>数组和字符串</td>
<td>01</td>
<td>一维数组。一维数组的定义和初始化及赋初值，数组元素的引用（含数组的length）。</td>
<td></td>
</tr>
<tr>
<td>02</td>
<td>二维数组。二维数组的定义和初始化及赋初值，数组元素的引用（含数组的length）。</td>
<td>必须类型相同</td>
<td></td>
<td></td>
</tr>
<tr>
<td>03</td>
<td>数组和数组元素作为方法的参数传递</td>
<td>数组名直接传递地址，数组元素是值传递</td>
<td></td>
<td></td>
</tr>
<tr>
<td>04</td>
<td>字符数组；字符串：String类(常用方法：length()，charAt()，subString()，equals(),compareTo()……);<strong>*\</strong>字符串数组****</td>
<td><strong><em>\</em>见blog**</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>类和对象</td>
<td>01</td>
<td>掌握类的概念，特点，对象的概念，对象域运算符；掌握类的声明：类名（形式，修饰符），方法（构造方法）；掌握对象的创建，类的封装，类的继承和多态（方法的重载、方法覆盖）；</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>接口与包、图形界面程序与其它</td>
<td>01</td>
<td>掌握接口的基本概念、接口的声明及包的概念；<strong>*\</strong>了解接口的实现、抽象类与方法、图形界面程序；****</td>
<td><strong><em>\</em>接口是一组常量+抽象方法*****</strong>*包是类和接口（比较宏观）****</td>
</tr>
<tr>
<td>02</td>
<td><strong>*\</strong>了解异常处理，多线程;****</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>G</td>
<td><strong><em>\</em>常用算法程序设计*****</strong>*（可包括函数）此类题目是程序阅读和程序填空题****</td>
<td>01</td>
<td>顺序、分支简单程序设计；</td>
<td></td>
</tr>
<tr>
<td>02</td>
<td>累加、累乘、多项式计算；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>03</td>
<td>统计个数（计数）、最值、平均值、公倍数、公约数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>04</td>
<td>穷举法（含素数等）、迭代法（Fib、数列）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>05</td>
<td>分类（排序）（包括数值或字符串）（包括数组元素插入）；检索（查找）（包括数值或字符串）；一维数组其它处理</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>06</td>
<td>数组矩阵的相加、相减和相乘，二维数组的处理</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>07</td>
<td>字符串处理</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>08</td>
<td>方法（函数），不包含<strong><em>\</em>排序、检索相关题（放G05）**</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>09</td>
<td>其它（面向对象部分）：构造方法、访问权限、类的继承、super、this、方法重载、方法覆盖</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/silmont2000.github.io/categories/%E6%96%B0%E7%9F%A5%E6%95%B4%E7%90%86/">新知整理</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/silmont2000.github.io/tags/Java/">Java</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC80OTU5NS8yNjA4Ng==">
    <script type="text/javascript">
      (function (d, s) {
        var j, e = d.getElementsByTagName(s)[0];

        if (typeof LivereTower === 'function') {
          return;
        }

        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.defer = true;

        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
  </div>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      零食总消耗<span id="busuanzi_value_site_pv"></span>袋 :P  
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      零食屋总客流量<span id="busuanzi_value_site_uv"></span>小只
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/silmont2000.github.io/js/main.js" ></script>


  <script  src="/silmont2000.github.io/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var post = $('#post');
      var toc = $('#toc');
      var tocLimMax = post.offset().top + post.height() - navHeight;

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = $('#board-ctn').css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>







  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java理论查漏&nbsp;",
      ],
      cursorChar: "：P",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/silmont2000.github.io/js/local-search.js" ></script>
  <script>
    var path = "/silmont2000.github.io/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>













</body>
</html>
